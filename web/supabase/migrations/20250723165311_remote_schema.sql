revoke delete on table "auth"."audit_log_entries" from "dashboard_user";

revoke insert on table "auth"."audit_log_entries" from "dashboard_user";

revoke references on table "auth"."audit_log_entries" from "dashboard_user";

revoke select on table "auth"."audit_log_entries" from "dashboard_user";

revoke trigger on table "auth"."audit_log_entries" from "dashboard_user";

revoke truncate on table "auth"."audit_log_entries" from "dashboard_user";

revoke update on table "auth"."audit_log_entries" from "dashboard_user";

revoke delete on table "auth"."flow_state" from "dashboard_user";

revoke insert on table "auth"."flow_state" from "dashboard_user";

revoke references on table "auth"."flow_state" from "dashboard_user";

revoke select on table "auth"."flow_state" from "dashboard_user";

revoke trigger on table "auth"."flow_state" from "dashboard_user";

revoke truncate on table "auth"."flow_state" from "dashboard_user";

revoke update on table "auth"."flow_state" from "dashboard_user";

revoke delete on table "auth"."identities" from "dashboard_user";

revoke insert on table "auth"."identities" from "dashboard_user";

revoke references on table "auth"."identities" from "dashboard_user";

revoke select on table "auth"."identities" from "dashboard_user";

revoke trigger on table "auth"."identities" from "dashboard_user";

revoke truncate on table "auth"."identities" from "dashboard_user";

revoke update on table "auth"."identities" from "dashboard_user";

revoke delete on table "auth"."instances" from "dashboard_user";

revoke insert on table "auth"."instances" from "dashboard_user";

revoke references on table "auth"."instances" from "dashboard_user";

revoke select on table "auth"."instances" from "dashboard_user";

revoke trigger on table "auth"."instances" from "dashboard_user";

revoke truncate on table "auth"."instances" from "dashboard_user";

revoke update on table "auth"."instances" from "dashboard_user";

revoke delete on table "auth"."mfa_amr_claims" from "dashboard_user";

revoke insert on table "auth"."mfa_amr_claims" from "dashboard_user";

revoke references on table "auth"."mfa_amr_claims" from "dashboard_user";

revoke select on table "auth"."mfa_amr_claims" from "dashboard_user";

revoke trigger on table "auth"."mfa_amr_claims" from "dashboard_user";

revoke truncate on table "auth"."mfa_amr_claims" from "dashboard_user";

revoke update on table "auth"."mfa_amr_claims" from "dashboard_user";

revoke delete on table "auth"."mfa_challenges" from "dashboard_user";

revoke insert on table "auth"."mfa_challenges" from "dashboard_user";

revoke references on table "auth"."mfa_challenges" from "dashboard_user";

revoke select on table "auth"."mfa_challenges" from "dashboard_user";

revoke trigger on table "auth"."mfa_challenges" from "dashboard_user";

revoke truncate on table "auth"."mfa_challenges" from "dashboard_user";

revoke update on table "auth"."mfa_challenges" from "dashboard_user";

revoke delete on table "auth"."mfa_factors" from "dashboard_user";

revoke insert on table "auth"."mfa_factors" from "dashboard_user";

revoke references on table "auth"."mfa_factors" from "dashboard_user";

revoke select on table "auth"."mfa_factors" from "dashboard_user";

revoke trigger on table "auth"."mfa_factors" from "dashboard_user";

revoke truncate on table "auth"."mfa_factors" from "dashboard_user";

revoke update on table "auth"."mfa_factors" from "dashboard_user";

revoke delete on table "auth"."one_time_tokens" from "dashboard_user";

revoke insert on table "auth"."one_time_tokens" from "dashboard_user";

revoke references on table "auth"."one_time_tokens" from "dashboard_user";

revoke select on table "auth"."one_time_tokens" from "dashboard_user";

revoke trigger on table "auth"."one_time_tokens" from "dashboard_user";

revoke truncate on table "auth"."one_time_tokens" from "dashboard_user";

revoke update on table "auth"."one_time_tokens" from "dashboard_user";

revoke delete on table "auth"."refresh_tokens" from "dashboard_user";

revoke insert on table "auth"."refresh_tokens" from "dashboard_user";

revoke references on table "auth"."refresh_tokens" from "dashboard_user";

revoke select on table "auth"."refresh_tokens" from "dashboard_user";

revoke trigger on table "auth"."refresh_tokens" from "dashboard_user";

revoke truncate on table "auth"."refresh_tokens" from "dashboard_user";

revoke update on table "auth"."refresh_tokens" from "dashboard_user";

revoke delete on table "auth"."saml_providers" from "dashboard_user";

revoke insert on table "auth"."saml_providers" from "dashboard_user";

revoke references on table "auth"."saml_providers" from "dashboard_user";

revoke select on table "auth"."saml_providers" from "dashboard_user";

revoke trigger on table "auth"."saml_providers" from "dashboard_user";

revoke truncate on table "auth"."saml_providers" from "dashboard_user";

revoke update on table "auth"."saml_providers" from "dashboard_user";

revoke delete on table "auth"."saml_relay_states" from "dashboard_user";

revoke insert on table "auth"."saml_relay_states" from "dashboard_user";

revoke references on table "auth"."saml_relay_states" from "dashboard_user";

revoke select on table "auth"."saml_relay_states" from "dashboard_user";

revoke trigger on table "auth"."saml_relay_states" from "dashboard_user";

revoke truncate on table "auth"."saml_relay_states" from "dashboard_user";

revoke update on table "auth"."saml_relay_states" from "dashboard_user";

revoke delete on table "auth"."schema_migrations" from "dashboard_user";

revoke insert on table "auth"."schema_migrations" from "dashboard_user";

revoke references on table "auth"."schema_migrations" from "dashboard_user";

revoke select on table "auth"."schema_migrations" from "dashboard_user";

revoke trigger on table "auth"."schema_migrations" from "dashboard_user";

revoke truncate on table "auth"."schema_migrations" from "dashboard_user";

revoke update on table "auth"."schema_migrations" from "dashboard_user";

revoke delete on table "auth"."schema_migrations" from "postgres";

revoke insert on table "auth"."schema_migrations" from "postgres";

revoke references on table "auth"."schema_migrations" from "postgres";

revoke trigger on table "auth"."schema_migrations" from "postgres";

revoke truncate on table "auth"."schema_migrations" from "postgres";

revoke update on table "auth"."schema_migrations" from "postgres";

revoke delete on table "auth"."sessions" from "dashboard_user";

revoke insert on table "auth"."sessions" from "dashboard_user";

revoke references on table "auth"."sessions" from "dashboard_user";

revoke select on table "auth"."sessions" from "dashboard_user";

revoke trigger on table "auth"."sessions" from "dashboard_user";

revoke truncate on table "auth"."sessions" from "dashboard_user";

revoke update on table "auth"."sessions" from "dashboard_user";

revoke delete on table "auth"."sso_domains" from "dashboard_user";

revoke insert on table "auth"."sso_domains" from "dashboard_user";

revoke references on table "auth"."sso_domains" from "dashboard_user";

revoke select on table "auth"."sso_domains" from "dashboard_user";

revoke trigger on table "auth"."sso_domains" from "dashboard_user";

revoke truncate on table "auth"."sso_domains" from "dashboard_user";

revoke update on table "auth"."sso_domains" from "dashboard_user";

revoke delete on table "auth"."sso_providers" from "dashboard_user";

revoke insert on table "auth"."sso_providers" from "dashboard_user";

revoke references on table "auth"."sso_providers" from "dashboard_user";

revoke select on table "auth"."sso_providers" from "dashboard_user";

revoke trigger on table "auth"."sso_providers" from "dashboard_user";

revoke truncate on table "auth"."sso_providers" from "dashboard_user";

revoke update on table "auth"."sso_providers" from "dashboard_user";

revoke delete on table "auth"."users" from "dashboard_user";

revoke insert on table "auth"."users" from "dashboard_user";

revoke references on table "auth"."users" from "dashboard_user";

revoke select on table "auth"."users" from "dashboard_user";

revoke trigger on table "auth"."users" from "dashboard_user";

revoke truncate on table "auth"."users" from "dashboard_user";

revoke update on table "auth"."users" from "dashboard_user";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION auth.email()
 RETURNS text
 LANGUAGE sql
 STABLE
AS $function$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.email', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')
  )::text
$function$
;

CREATE OR REPLACE FUNCTION auth.jwt()
 RETURNS jsonb
 LANGUAGE sql
 STABLE
AS $function$
  select 
    coalesce(
        nullif(current_setting('request.jwt.claim', true), ''),
        nullif(current_setting('request.jwt.claims', true), '')
    )::jsonb
$function$
;

CREATE OR REPLACE FUNCTION auth.role()
 RETURNS text
 LANGUAGE sql
 STABLE
AS $function$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.role', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')
  )::text
$function$
;

CREATE OR REPLACE FUNCTION auth.uid()
 RETURNS uuid
 LANGUAGE sql
 STABLE
AS $function$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.sub', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')
  )::uuid
$function$
;


drop trigger if exists "enforce_bucket_name_length_trigger" on "storage"."buckets";

drop trigger if exists "objects_delete_delete_prefix" on "storage"."objects";

drop trigger if exists "objects_insert_create_prefix" on "storage"."objects";

drop trigger if exists "objects_update_create_prefix" on "storage"."objects";

drop trigger if exists "prefixes_create_hierarchy" on "storage"."prefixes";

drop trigger if exists "prefixes_delete_hierarchy" on "storage"."prefixes";

revoke delete on table "storage"."buckets_analytics" from "anon";

revoke insert on table "storage"."buckets_analytics" from "anon";

revoke references on table "storage"."buckets_analytics" from "anon";

revoke select on table "storage"."buckets_analytics" from "anon";

revoke trigger on table "storage"."buckets_analytics" from "anon";

revoke truncate on table "storage"."buckets_analytics" from "anon";

revoke update on table "storage"."buckets_analytics" from "anon";

revoke delete on table "storage"."buckets_analytics" from "authenticated";

revoke insert on table "storage"."buckets_analytics" from "authenticated";

revoke references on table "storage"."buckets_analytics" from "authenticated";

revoke select on table "storage"."buckets_analytics" from "authenticated";

revoke trigger on table "storage"."buckets_analytics" from "authenticated";

revoke truncate on table "storage"."buckets_analytics" from "authenticated";

revoke update on table "storage"."buckets_analytics" from "authenticated";

revoke delete on table "storage"."buckets_analytics" from "service_role";

revoke insert on table "storage"."buckets_analytics" from "service_role";

revoke references on table "storage"."buckets_analytics" from "service_role";

revoke select on table "storage"."buckets_analytics" from "service_role";

revoke trigger on table "storage"."buckets_analytics" from "service_role";

revoke truncate on table "storage"."buckets_analytics" from "service_role";

revoke update on table "storage"."buckets_analytics" from "service_role";

revoke select on table "storage"."iceberg_namespaces" from "anon";

revoke select on table "storage"."iceberg_namespaces" from "authenticated";

revoke delete on table "storage"."iceberg_namespaces" from "service_role";

revoke insert on table "storage"."iceberg_namespaces" from "service_role";

revoke references on table "storage"."iceberg_namespaces" from "service_role";

revoke select on table "storage"."iceberg_namespaces" from "service_role";

revoke trigger on table "storage"."iceberg_namespaces" from "service_role";

revoke truncate on table "storage"."iceberg_namespaces" from "service_role";

revoke update on table "storage"."iceberg_namespaces" from "service_role";

revoke select on table "storage"."iceberg_tables" from "anon";

revoke select on table "storage"."iceberg_tables" from "authenticated";

revoke delete on table "storage"."iceberg_tables" from "service_role";

revoke insert on table "storage"."iceberg_tables" from "service_role";

revoke references on table "storage"."iceberg_tables" from "service_role";

revoke select on table "storage"."iceberg_tables" from "service_role";

revoke trigger on table "storage"."iceberg_tables" from "service_role";

revoke truncate on table "storage"."iceberg_tables" from "service_role";

revoke update on table "storage"."iceberg_tables" from "service_role";

revoke delete on table "storage"."migrations" from "anon";

revoke insert on table "storage"."migrations" from "anon";

revoke references on table "storage"."migrations" from "anon";

revoke select on table "storage"."migrations" from "anon";

revoke trigger on table "storage"."migrations" from "anon";

revoke truncate on table "storage"."migrations" from "anon";

revoke update on table "storage"."migrations" from "anon";

revoke delete on table "storage"."migrations" from "authenticated";

revoke insert on table "storage"."migrations" from "authenticated";

revoke references on table "storage"."migrations" from "authenticated";

revoke select on table "storage"."migrations" from "authenticated";

revoke trigger on table "storage"."migrations" from "authenticated";

revoke truncate on table "storage"."migrations" from "authenticated";

revoke update on table "storage"."migrations" from "authenticated";

revoke delete on table "storage"."migrations" from "postgres";

revoke insert on table "storage"."migrations" from "postgres";

revoke references on table "storage"."migrations" from "postgres";

revoke select on table "storage"."migrations" from "postgres";

revoke trigger on table "storage"."migrations" from "postgres";

revoke truncate on table "storage"."migrations" from "postgres";

revoke update on table "storage"."migrations" from "postgres";

revoke delete on table "storage"."migrations" from "service_role";

revoke insert on table "storage"."migrations" from "service_role";

revoke references on table "storage"."migrations" from "service_role";

revoke select on table "storage"."migrations" from "service_role";

revoke trigger on table "storage"."migrations" from "service_role";

revoke truncate on table "storage"."migrations" from "service_role";

revoke update on table "storage"."migrations" from "service_role";

revoke delete on table "storage"."prefixes" from "anon";

revoke insert on table "storage"."prefixes" from "anon";

revoke references on table "storage"."prefixes" from "anon";

revoke select on table "storage"."prefixes" from "anon";

revoke trigger on table "storage"."prefixes" from "anon";

revoke truncate on table "storage"."prefixes" from "anon";

revoke update on table "storage"."prefixes" from "anon";

revoke delete on table "storage"."prefixes" from "authenticated";

revoke insert on table "storage"."prefixes" from "authenticated";

revoke references on table "storage"."prefixes" from "authenticated";

revoke select on table "storage"."prefixes" from "authenticated";

revoke trigger on table "storage"."prefixes" from "authenticated";

revoke truncate on table "storage"."prefixes" from "authenticated";

revoke update on table "storage"."prefixes" from "authenticated";

revoke delete on table "storage"."prefixes" from "service_role";

revoke insert on table "storage"."prefixes" from "service_role";

revoke references on table "storage"."prefixes" from "service_role";

revoke select on table "storage"."prefixes" from "service_role";

revoke trigger on table "storage"."prefixes" from "service_role";

revoke truncate on table "storage"."prefixes" from "service_role";

revoke update on table "storage"."prefixes" from "service_role";

alter table "storage"."iceberg_namespaces" drop constraint "iceberg_namespaces_bucket_id_fkey";

alter table "storage"."iceberg_tables" drop constraint "iceberg_tables_bucket_id_fkey";

alter table "storage"."iceberg_tables" drop constraint "iceberg_tables_namespace_id_fkey";

alter table "storage"."prefixes" drop constraint "prefixes_bucketId_fkey";

drop function if exists "storage"."add_prefixes"(_bucket_id text, _name text);

drop function if exists "storage"."delete_prefix"(_bucket_id text, _name text);

drop function if exists "storage"."delete_prefix_hierarchy_trigger"();

drop function if exists "storage"."enforce_bucket_name_length"();

drop function if exists "storage"."get_level"(name text);

drop function if exists "storage"."get_prefix"(name text);

drop function if exists "storage"."get_prefixes"(name text);

drop function if exists "storage"."objects_insert_prefix_trigger"();

drop function if exists "storage"."objects_update_prefix_trigger"();

drop function if exists "storage"."prefixes_insert_trigger"();

drop function if exists "storage"."search_legacy_v1"(prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text);

drop function if exists "storage"."search_v1_optimised"(prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text);

drop function if exists "storage"."search_v2"(prefix text, bucket_name text, limits integer, levels integer, start_after text);

alter table "storage"."buckets_analytics" drop constraint "buckets_analytics_pkey";

alter table "storage"."iceberg_namespaces" drop constraint "iceberg_namespaces_pkey";

alter table "storage"."iceberg_tables" drop constraint "iceberg_tables_pkey";

alter table "storage"."prefixes" drop constraint "prefixes_pkey";

drop index if exists "storage"."buckets_analytics_pkey";

drop index if exists "storage"."iceberg_namespaces_pkey";

drop index if exists "storage"."iceberg_tables_pkey";

drop index if exists "storage"."idx_iceberg_namespaces_bucket_id";

drop index if exists "storage"."idx_iceberg_tables_namespace_id";

drop index if exists "storage"."idx_name_bucket_level_unique";

drop index if exists "storage"."idx_objects_lower_name";

drop index if exists "storage"."idx_prefixes_lower_name";

drop index if exists "storage"."objects_bucket_id_level_idx";

drop index if exists "storage"."prefixes_pkey";

drop table "storage"."buckets_analytics";

drop table "storage"."iceberg_namespaces";

drop table "storage"."iceberg_tables";

drop table "storage"."prefixes";

alter table "storage"."buckets" drop column "type";

alter table "storage"."objects" drop column "level";

drop type "storage"."buckettype";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  INSERT INTO "storage"."objects" ("bucket_id", "name", "owner", "metadata") VALUES (bucketid, name, owner, metadata);
  -- hack to rollback the successful insert
  RAISE sqlstate 'PT200' using
  message = 'ROLLBACK',
  detail = 'rollback successful insert';
END
$function$
;

CREATE OR REPLACE FUNCTION storage.extension(name text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
_parts text[];
_filename text;
BEGIN
	select string_to_array(name, '/') into _parts;
	select _parts[array_length(_parts,1)] into _filename;
	-- @todo return the last part instead of 2
	return reverse(split_part(reverse(_filename), '.', 1));
END
$function$
;

CREATE OR REPLACE FUNCTION storage.filename(name text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
_parts text[];
BEGIN
	select string_to_array(name, '/') into _parts;
	return _parts[array_length(_parts,1)];
END
$function$
;

CREATE OR REPLACE FUNCTION storage.foldername(name text)
 RETURNS text[]
 LANGUAGE plpgsql
AS $function$
DECLARE
_parts text[];
BEGIN
	select string_to_array(name, '/') into _parts;
	return _parts[1:array_length(_parts,1)-1];
END
$function$
;

CREATE OR REPLACE FUNCTION storage.get_size_by_bucket()
 RETURNS TABLE(size bigint, bucket_id text)
 LANGUAGE plpgsql
AS $function$
BEGIN
    return query
        select sum((metadata->>'size')::int) as size, obj.bucket_id
        from "storage".objects as obj
        group by obj.bucket_id;
END
$function$
;

CREATE OR REPLACE FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text)
 RETURNS TABLE(key text, id text, created_at timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY EXECUTE
        'SELECT DISTINCT ON(key COLLATE "C") * from (
            SELECT
                CASE
                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN
                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))
                    ELSE
                        key
                END AS key, id, created_at
            FROM
                storage.s3_multipart_uploads
            WHERE
                bucket_id = $5 AND
                key ILIKE $1 || ''%'' AND
                CASE
                    WHEN $4 != '''' AND $6 = '''' THEN
                        CASE
                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN
                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE "C" > $4
                            ELSE
                                key COLLATE "C" > $4
                            END
                    ELSE
                        true
                END AND
                CASE
                    WHEN $6 != '''' THEN
                        id COLLATE "C" > $6
                    ELSE
                        true
                    END
            ORDER BY
                key COLLATE "C" ASC, created_at ASC) as e order by key COLLATE "C" LIMIT $3'
        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;
END;
$function$
;

CREATE OR REPLACE FUNCTION storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text)
 RETURNS TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY EXECUTE
        'SELECT DISTINCT ON(name COLLATE "C") * from (
            SELECT
                CASE
                    WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN
                        substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)))
                    ELSE
                        name
                END AS name, id, metadata, updated_at
            FROM
                storage.objects
            WHERE
                bucket_id = $5 AND
                name ILIKE $1 || ''%'' AND
                CASE
                    WHEN $6 != '''' THEN
                    name COLLATE "C" > $6
                ELSE true END
                AND CASE
                    WHEN $4 != '''' THEN
                        CASE
                            WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN
                                substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1))) COLLATE "C" > $4
                            ELSE
                                name COLLATE "C" > $4
                            END
                    ELSE
                        true
                END
            ORDER BY
                name COLLATE "C" ASC) as e order by name COLLATE "C" LIMIT $3'
        USING prefix_param, delimiter_param, max_keys, next_token, bucket_id, start_after;
END;
$function$
;

CREATE OR REPLACE FUNCTION storage.operation()
 RETURNS text
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
    RETURN current_setting('storage.operation', true);
END;
$function$
;

CREATE OR REPLACE FUNCTION storage.search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)
 RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
 LANGUAGE plpgsql
 STABLE
AS $function$
declare
  v_order_by text;
  v_sort_order text;
begin
  case
    when sortcolumn = 'name' then
      v_order_by = 'name';
    when sortcolumn = 'updated_at' then
      v_order_by = 'updated_at';
    when sortcolumn = 'created_at' then
      v_order_by = 'created_at';
    when sortcolumn = 'last_accessed_at' then
      v_order_by = 'last_accessed_at';
    else
      v_order_by = 'name';
  end case;

  case
    when sortorder = 'asc' then
      v_sort_order = 'asc';
    when sortorder = 'desc' then
      v_sort_order = 'desc';
    else
      v_sort_order = 'asc';
  end case;

  v_order_by = v_order_by || ' ' || v_sort_order;

  return query execute
    'with folders as (
       select path_tokens[$1] as folder
       from storage.objects
         where objects.name ilike $2 || $3 || ''%''
           and bucket_id = $4
           and array_length(objects.path_tokens, 1) <> $1
       group by folder
       order by folder ' || v_sort_order || '
     )
     (select folder as "name",
            null as id,
            null as updated_at,
            null as created_at,
            null as last_accessed_at,
            null as metadata from folders)
     union all
     (select path_tokens[$1] as "name",
            id,
            updated_at,
            created_at,
            last_accessed_at,
            metadata
     from storage.objects
     where objects.name ilike $2 || $3 || ''%''
       and bucket_id = $4
       and array_length(objects.path_tokens, 1) = $1
     order by ' || v_order_by || ')
     limit $5
     offset $6' using levels, prefix, search, bucketname, limits, offsets;
end;
$function$
;

CREATE OR REPLACE FUNCTION storage.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = now();
    RETURN NEW; 
END;
$function$
;


